/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: coin.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "coin.pb-c.h"
void   coin__envelope__init
                     (Coin__Envelope         *message)
{
  static const Coin__Envelope init_value = COIN__ENVELOPE__INIT;
  *message = init_value;
}
size_t coin__envelope__get_packed_size
                     (const Coin__Envelope *message)
{
  assert(message->base.descriptor == &coin__envelope__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__envelope__pack
                     (const Coin__Envelope *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__envelope__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__envelope__pack_to_buffer
                     (const Coin__Envelope *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__envelope__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__Envelope *
       coin__envelope__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__Envelope *)
     protobuf_c_message_unpack (&coin__envelope__descriptor,
                                allocator, len, data);
}
void   coin__envelope__free_unpacked
                     (Coin__Envelope *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__envelope__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__request_task__init
                     (Coin__RequestTask         *message)
{
  static const Coin__RequestTask init_value = COIN__REQUEST_TASK__INIT;
  *message = init_value;
}
size_t coin__request_task__get_packed_size
                     (const Coin__RequestTask *message)
{
  assert(message->base.descriptor == &coin__request_task__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__request_task__pack
                     (const Coin__RequestTask *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__request_task__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__request_task__pack_to_buffer
                     (const Coin__RequestTask *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__request_task__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__RequestTask *
       coin__request_task__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__RequestTask *)
     protobuf_c_message_unpack (&coin__request_task__descriptor,
                                allocator, len, data);
}
void   coin__request_task__free_unpacked
                     (Coin__RequestTask *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__request_task__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__task__init
                     (Coin__Task         *message)
{
  static const Coin__Task init_value = COIN__TASK__INIT;
  *message = init_value;
}
size_t coin__task__get_packed_size
                     (const Coin__Task *message)
{
  assert(message->base.descriptor == &coin__task__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__task__pack
                     (const Coin__Task *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__task__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__task__pack_to_buffer
                     (const Coin__Task *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__task__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__Task *
       coin__task__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__Task *)
     protobuf_c_message_unpack (&coin__task__descriptor,
                                allocator, len, data);
}
void   coin__task__free_unpacked
                     (Coin__Task *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__task__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__solution__init
                     (Coin__Solution         *message)
{
  static const Coin__Solution init_value = COIN__SOLUTION__INIT;
  *message = init_value;
}
size_t coin__solution__get_packed_size
                     (const Coin__Solution *message)
{
  assert(message->base.descriptor == &coin__solution__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__solution__pack
                     (const Coin__Solution *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__solution__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__solution__pack_to_buffer
                     (const Coin__Solution *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__solution__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__Solution *
       coin__solution__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__Solution *)
     protobuf_c_message_unpack (&coin__solution__descriptor,
                                allocator, len, data);
}
void   coin__solution__free_unpacked
                     (Coin__Solution *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__solution__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__verification__init
                     (Coin__Verification         *message)
{
  static const Coin__Verification init_value = COIN__VERIFICATION__INIT;
  *message = init_value;
}
size_t coin__verification__get_packed_size
                     (const Coin__Verification *message)
{
  assert(message->base.descriptor == &coin__verification__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__verification__pack
                     (const Coin__Verification *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__verification__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__verification__pack_to_buffer
                     (const Coin__Verification *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__verification__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__Verification *
       coin__verification__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__Verification *)
     protobuf_c_message_unpack (&coin__verification__descriptor,
                                allocator, len, data);
}
void   coin__verification__free_unpacked
                     (Coin__Verification *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__verification__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__heartbeat__init
                     (Coin__Heartbeat         *message)
{
  static const Coin__Heartbeat init_value = COIN__HEARTBEAT__INIT;
  *message = init_value;
}
size_t coin__heartbeat__get_packed_size
                     (const Coin__Heartbeat *message)
{
  assert(message->base.descriptor == &coin__heartbeat__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__heartbeat__pack
                     (const Coin__Heartbeat *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__heartbeat__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__heartbeat__pack_to_buffer
                     (const Coin__Heartbeat *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__heartbeat__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__Heartbeat *
       coin__heartbeat__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__Heartbeat *)
     protobuf_c_message_unpack (&coin__heartbeat__descriptor,
                                allocator, len, data);
}
void   coin__heartbeat__free_unpacked
                     (Coin__Heartbeat *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__heartbeat__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   coin__heartbeat_reply__init
                     (Coin__HeartbeatReply         *message)
{
  static const Coin__HeartbeatReply init_value = COIN__HEARTBEAT_REPLY__INIT;
  *message = init_value;
}
size_t coin__heartbeat_reply__get_packed_size
                     (const Coin__HeartbeatReply *message)
{
  assert(message->base.descriptor == &coin__heartbeat_reply__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t coin__heartbeat_reply__pack
                     (const Coin__HeartbeatReply *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &coin__heartbeat_reply__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t coin__heartbeat_reply__pack_to_buffer
                     (const Coin__HeartbeatReply *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &coin__heartbeat_reply__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Coin__HeartbeatReply *
       coin__heartbeat_reply__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Coin__HeartbeatReply *)
     protobuf_c_message_unpack (&coin__heartbeat_reply__descriptor,
                                allocator, len, data);
}
void   coin__heartbeat_reply__free_unpacked
                     (Coin__HeartbeatReply *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &coin__heartbeat_reply__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor coin__envelope__field_descriptors[6] =
{
  {
    "request_task",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, request_task),
    &coin__request_task__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "task",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, task),
    &coin__task__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "solution",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, solution),
    &coin__solution__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "verification",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, verification),
    &coin__verification__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "heartbeat",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, heartbeat),
    &coin__heartbeat__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "heartbeat_reply",
    6,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Coin__Envelope, body_case),
    offsetof(Coin__Envelope, heartbeat_reply),
    &coin__heartbeat_reply__descriptor,
    NULL,
    PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__envelope__field_indices_by_name[] = {
  4,   /* field[4] = heartbeat */
  5,   /* field[5] = heartbeat_reply */
  0,   /* field[0] = request_task */
  2,   /* field[2] = solution */
  1,   /* field[1] = task */
  3,   /* field[3] = verification */
};
static const ProtobufCIntRange coin__envelope__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor coin__envelope__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.Envelope",
  "Envelope",
  "Coin__Envelope",
  "coin",
  sizeof(Coin__Envelope),
  6,
  coin__envelope__field_descriptors,
  coin__envelope__field_indices_by_name,
  1,  coin__envelope__number_ranges,
  (ProtobufCMessageInit) coin__envelope__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__request_task__field_descriptors[1] =
{
  {
    "username",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__RequestTask, username),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__request_task__field_indices_by_name[] = {
  0,   /* field[0] = username */
};
static const ProtobufCIntRange coin__request_task__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor coin__request_task__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.RequestTask",
  "RequestTask",
  "Coin__RequestTask",
  "coin",
  sizeof(Coin__RequestTask),
  1,
  coin__request_task__field_descriptors,
  coin__request_task__field_indices_by_name,
  1,  coin__request_task__number_ranges,
  (ProtobufCMessageInit) coin__request_task__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__task__field_descriptors[3] =
{
  {
    "block",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__Task, block),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "difficulty_mask",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Coin__Task, difficulty_mask),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sequence_num",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Coin__Task, sequence_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__task__field_indices_by_name[] = {
  0,   /* field[0] = block */
  1,   /* field[1] = difficulty_mask */
  2,   /* field[2] = sequence_num */
};
static const ProtobufCIntRange coin__task__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor coin__task__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.Task",
  "Task",
  "Coin__Task",
  "coin",
  sizeof(Coin__Task),
  3,
  coin__task__field_descriptors,
  coin__task__field_indices_by_name,
  1,  coin__task__number_ranges,
  (ProtobufCMessageInit) coin__task__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__solution__field_descriptors[5] =
{
  {
    "username",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__Solution, username),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "block",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__Solution, block),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "difficulty_mask",
    3,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Coin__Solution, difficulty_mask),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "nonce",
    4,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Coin__Solution, nonce),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sequence_num",
    5,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Coin__Solution, sequence_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__solution__field_indices_by_name[] = {
  1,   /* field[1] = block */
  2,   /* field[2] = difficulty_mask */
  3,   /* field[3] = nonce */
  4,   /* field[4] = sequence_num */
  0,   /* field[0] = username */
};
static const ProtobufCIntRange coin__solution__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor coin__solution__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.Solution",
  "Solution",
  "Coin__Solution",
  "coin",
  sizeof(Coin__Solution),
  5,
  coin__solution__field_descriptors,
  coin__solution__field_indices_by_name,
  1,  coin__solution__number_ranges,
  (ProtobufCMessageInit) coin__solution__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__verification__field_descriptors[2] =
{
  {
    "ok",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_BOOL,
    0,   /* quantifier_offset */
    offsetof(Coin__Verification, ok),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "error_description",
    2,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__Verification, error_description),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__verification__field_indices_by_name[] = {
  1,   /* field[1] = error_description */
  0,   /* field[0] = ok */
};
static const ProtobufCIntRange coin__verification__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor coin__verification__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.Verification",
  "Verification",
  "Coin__Verification",
  "coin",
  sizeof(Coin__Verification),
  2,
  coin__verification__field_descriptors,
  coin__verification__field_indices_by_name,
  1,  coin__verification__number_ranges,
  (ProtobufCMessageInit) coin__verification__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__heartbeat__field_descriptors[1] =
{
  {
    "username",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Coin__Heartbeat, username),
    NULL,
    &protobuf_c_empty_string,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__heartbeat__field_indices_by_name[] = {
  0,   /* field[0] = username */
};
static const ProtobufCIntRange coin__heartbeat__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor coin__heartbeat__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.Heartbeat",
  "Heartbeat",
  "Coin__Heartbeat",
  "coin",
  sizeof(Coin__Heartbeat),
  1,
  coin__heartbeat__field_descriptors,
  coin__heartbeat__field_indices_by_name,
  1,  coin__heartbeat__number_ranges,
  (ProtobufCMessageInit) coin__heartbeat__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor coin__heartbeat_reply__field_descriptors[1] =
{
  {
    "sequence_num",
    1,
    PROTOBUF_C_LABEL_NONE,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Coin__HeartbeatReply, sequence_num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned coin__heartbeat_reply__field_indices_by_name[] = {
  0,   /* field[0] = sequence_num */
};
static const ProtobufCIntRange coin__heartbeat_reply__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor coin__heartbeat_reply__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "coin.HeartbeatReply",
  "HeartbeatReply",
  "Coin__HeartbeatReply",
  "coin",
  sizeof(Coin__HeartbeatReply),
  1,
  coin__heartbeat_reply__field_descriptors,
  coin__heartbeat_reply__field_indices_by_name,
  1,  coin__heartbeat_reply__number_ranges,
  (ProtobufCMessageInit) coin__heartbeat_reply__init,
  NULL,NULL,NULL    /* reserved[123] */
};
